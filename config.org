#+TITLE: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el :comments link
* My Emacs Configuration
this is my attempt at a home-brewed Emacs configuration taking what I've
learned from using doom Emacs exclusively for two years of
professional work

** elpaca
#+begin_src emacs-lisp
  (defvar elpaca-installer-version 0.8)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                    ,@(when-let* ((depth (plist-get order :depth)))
                                                        (list (format "--depth=%d" depth) "--no-single-branch"))
                                                    ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))

  (elpaca elpaca-use-package
  ;; Enable use-package :ensure support for Elpaca.
    (elpaca-use-package-mode))
  (elpaca org
    (require 'org))
  (elpaca-wait)
#+end_src
*** early init

#+begin_src emacs-lisp :tangle ./early-init.el
  (setq package-enable-at-startup nil)
#+end_src

** performance
 
#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (use-package gcmh
    :ensure t
    :config
    (gcmh-mode 1)
    ;; The default is 800 kilobytes.  Measured in bytes.
    ;; Profile emacs startup
    (add-hook 'emacs-startup-hook
              (lambda ()
                (message "*** Emacs loaded in %s seconds with %d garbage collections."
                         (emacs-init-time "%.2f")
                         gcs-done))))
  (use-package compat
    :ensure t
    :demand t)

  (use-package s
    :ensure t
    :demand t)

  (use-package transient
    :ensure t
    :demand t
    :after compat
    :bind(( "C-c '" . #'my/lsp-transient)))
  (elpaca-wait)
#+end_src
 
#+RESULTS:
| (lambda nil (message *** Emacs loaded in %s seconds with %d garbage collections. (emacs-init-time %.2f) gcs-done)) | #[0 \301!\210eb\210\302 \210\303\304!\207 [dashboard-buffer-name switch-to-buffer redisplay run-hooks dashboard-after-initialize-hook] 2] | (closure (t) nil (message *** Emacs loaded in %s seconds with %d garbage collections. (emacs-init-time %.2f) gcs-done)) |
 
** allow themes and babel blocks
#+begin_src emacs-lisp
  (setq custom-safe-themes t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-return-follow-link t)
#+end_src
 
#+RESULTS:
: t
 
 
** Native compilation
 
#+begin_src emacs-lisp
  ;; Silence compiler warnings as they can be pretty disruptive
  (setq native-comp-async-report-warnings-errors nil)

  ;; Set the right directory to store the native comp cache
  (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory))
#+end_src
 
#+RESULTS:
| /home/karim/.cache/emacs/eln-cache/ | /home/karim/.emacs.d/eln-cache/ | /home/karim/.guix-profile/lib/emacs/native-site-lisp | /gnu/store/3bsvi1gvbacnpbxrv6v1334d2d256766-emacs-29.3/lib/emacs/29.3/native-lisp/ |
** Adding sources for packages
#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives
          '(("gnu" . "https://elpa.gnu.org/packages/")
            ("melpa" . "https://melpa.org/packages/")
            ("org" . "https://orgmode.org/elpa/")))
  (setq use-package-always-ensure t)
      ;; Comment/uncomment this line to enable MELPA Stable if desired.  See `package-archive-priorities`
      ;; and `package-pinned-packages`. Most users will not need or want to do this.
      ;;(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  ;; (package-initialize)
#+end_src 
 
#+RESULTS:


** Package Management

** org babel
#+begin_src emacs-lisp :noweb yes
  (use-package ob-powershell
       :ensure (ob-powershell :type git
                    :host github
                    :repo "rkiggen/ob-powershell")
       :after org)
  (use-package ob-fsharp
    :after org)
  (use-package ob-restclient
    :after org)
  (use-package ob-http
    :ensure (ob-http :type git
                       :host github
                       :repo "zweifisch/ob-http")
    :after org
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     (quote (
             (shell . t)
             (python . t)
             (ditaa . t)
             (gnuplot . t)
             (fsharp . t)
             (restclient . t)
             (powershell . t)
             (http . t)))))
#+end_src

#+RESULTS:
: t


#+begin_src emacs-lisp 

#+end_src

#+RESULTS: babel-packages
: ob-fsharp
#+begin_src sh
  sleep 3 && echo "Hello World"
#+end_src

#+RESULTS:
: Hello World
 
** formatting
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
      (setq-default tab-width 4)  ; Set width for tabs
      (setq-default require-final-newline nil)
      (setq-default mode-require-final-newline nil)
      (setq c-require-final-newline '((c-mode . nil) (c++-mode . nil) (objc-mode . nil)))
      (setq-default buffer-file-coding-system 'utf-8-unix)
    (global-auto-revert-mode 1)
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (set-face-attribute 'default nil :font "Fira Code-16")

      (setq-default major-mode
                    (lambda () ; guess major mode from file name
                      (unless buffer-file-name
                        (let ((buffer-file-name (buffer-name)))
                          (set-auto-mode)))))

      (setq confirm-kill-emacs #'yes-or-no-p)
      (setq window-resize-pixelwise t)
      (setq frame-resize-pixelwise t)
      (save-place-mode t)
      (savehist-mode t)
      (recentf-mode t)
    (defalias 'yes-or-no-p 'y-or-n-p)
    (global-set-key (kbd "C-c l") #'org-store-link)


  (setq compilation-ask-about-save nil)
#+end_src
 
#+RESULTS:
 
* Behaviour
#+begin_src emacs-lisp
  (setq-default abbrev-mode t)
#+end_src

** eshell
#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :after eshell
    :init
    (add-to-list 'eshell-path-env-list "~/.local/bin/"))
#+end_src
* packages

** Keep .emacs.d Clean
Ensuring a clean .emacs.d directory by relocating transient files.
I don't want a bunch of transient files showing up as untracked in the Git repo so I move them all to another location.

#+begin_src emacs-lisp
  (use-package no-littering
    :ensure t
    :init
    ;; Set up no-littering early in initialization
    (require 'no-littering)

    :config
    ;; Keep customization settings in a separate file
    (setq custom-file (no-littering-expand-etc-file-name "custom.el"))
    (load custom-file :noerror :nomessage)

    ;; Configure auto-save and backup locations
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

    ;; Store lock files in a separate directory
    (setq lock-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "lock-files/") t)))

    ;; Ensure directories exist
    (make-directory (no-littering-expand-var-file-name "auto-save/") :parents)
    (make-directory (no-littering-expand-var-file-name "lock-files/") :parents)

    ;; Backup settings
    (setq backup-directory-alist
          `(("." . ,(no-littering-expand-var-file-name "backup/"))))
    (setq backup-by-copying t)      ; Don't delink hardlinks
    (setq delete-old-versions t)    ; Clean up backup files
    (setq version-control t)        ; Use version numbers on backups
    (setq kept-new-versions 5)      ; Keep 5 newest versions
    (setq kept-old-versions 2)      ; Keep 2 oldest versions
    (setq make-backup-files nil)    ; Disable backup files
    (setq vc-make-backup-files nil) ; Don't backup version controlled files

    ;; Save history and places
    (setq savehist-file (no-littering-expand-var-file-name "savehist.el"))
    (setq save-place-file (no-littering-expand-var-file-name "save-place.el"))
    ;; Store auto-save-list files in var directory
    (setq auto-save-list-file-prefix 
          (no-littering-expand-var-file-name "auto-save-list/.saves-"))

    ;; Keep transient files in var directory
    (setq transient-history-file 
          (no-littering-expand-var-file-name "transient/history.el"))
    (setq transient-levels-file 
          (no-littering-expand-var-file-name "transient/levels.el"))
    (setq transient-values-file 
          (no-littering-expand-var-file-name "transient/values.el"))

    ;; Persist recentf list between sessions
    (setq recentf-save-file 
          (no-littering-expand-var-file-name "recentf"))

    ;; Store bookmarks file in etc directory
    (setq bookmark-default-file 
          (no-littering-expand-etc-file-name "bookmarks")))

  ;; Enable save-place-mode to remember cursor position
  (save-place-mode 1)

  ;; Enable savehist-mode to persist history
  (savehist-mode 1)

  ;; Enable recentf-mode to track recently opened files
  (recentf-mode 1)
#+end_src
 
#+RESULTS:
 
*Guix Packages*
** Update Load Path
I've got a folder of custom Emacs Lisp libraries which must be added to the load path.
#+begin_src emacs-lisp
  ;; Add my library path to load-path
  (push "~/.emacs.d/lisp" load-path)
#+end_src
 
** Dashboard
#+begin_src emacs-lisp
  (use-package all-the-icons)
  (use-package dashboard
    :config
  (setq dashboard-startup-banner 'logo)
  (setq dashboard-set-heading-icons t))
#+end_src
 
#+RESULTS:
: t
** Keybinding Panel (which-key)
 
[[https://github.com/justbur/emacs-which-key][which-key]] is great for getting an overview of what keybindings are available
based on the prefix keys you entered.  Learned about this one from Spacemacs.
 
#+begin_src emacs-lisp
  (use-package diminish)
  (use-package which-key
    :config
    (diminish 'which-key-mode)
    (which-key-mode)
    (setq which-key-idle-delay 0.3))
#+end_src
** Doom-themes
A little bit of everything honestly you will find something you like
here.  I am currently using modus-vivendi though. Which can be
customized as you please as well.
#+begin_src emacs-lisp
  (use-package doom-themes)
  (load-theme 'modus-vivendi)
#+end_src
** Doom-modeline
#+begin_src emacs-lisp
  (use-package doom-modeline
    :config
    (doom-modeline-mode 1)
    (setf doom-modeline-icon t))
#+end_src
 
#+RESULTS:
: t
** Winner-mode
#+begin_src emacs-lisp
  (setf winner-mode 1)

  (use-package nerd-icons
    :ensure t)
  (use-package nerd-icons-completion
    :ensure t
    :after marginalia
    :config
    (nerd-icons-completion-marginalia-setup)
    (nerd-icons-completion-mode 1))
#+end_src
** Version control
[[https://magit.vc/][Magit]] is one of emacs best features. It's been around forever at it has truly helped me understand the intricasies of git.
 
if this isn't you cup of tea and you're on windows or mac, then I
highly recommend [[https://magit.vc/][Fork]]

It might be hard to imagine, but having your source control directly
where you browse code is immennsely freeing and you don't break you
flow as much. On top of that you have all of your code search,
navigation etc. available since you're in your editor.
#+begin_src emacs-lisp
  (use-package magit
    :config
    (setf magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1
          magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1
          magit-save-repository-buffers 'dontask
          ediff-window-setup-function 'ediff-setup-windows-plain)
    :bind (("C-c v" . #'my-git-commands)))

  (use-package magit-todos)

  (use-package conventional-commit
    :ensure (conventional-commit
               :type git
               :host github
               :repo "akirak/conventional-commit.el")
    :hook (git-commit-mode . conventional-commit-setup))
  (use-package git-timemachine
    :ensure t)
  (use-package git-cliff
    :config
    (setf git-cliff-executable "~/.cargo/bin/git-cliff"))
  (transient-define-prefix my-git-commands ()
    "A transient for common git operations."
    ["Git Commands"
     ["Magit"
      ("g" "Status" magit-status)
      ("b" "blame" magit-blame-addition)
      ("C" "Clone" magit-clone)
      ]
     ["Timemachine"
      ("t" "Toggle Timemachine" git-timemachine-toggle)]])
#+end_src

** Puni (structural editing - sexp / balanced expressions)
#+begin_src emacs-lisp
  ;; Install and configure Puni
  (use-package puni
    :init
    ;; Enable puni-mode globally
    (puni-global-mode)
    :config
    ;; Define keybindings similar to Paredit
    (define-key puni-mode-map (kbd "C-k") 'puni-kill-line)
    (define-key puni-mode-map (kbd "M-(") 'puni-wrap-round)
    (define-key puni-mode-map (kbd "M-[") 'puni-wrap-square)
    (define-key puni-mode-map (kbd "M-{") 'puni-wrap-curly)
    (define-key puni-mode-map (kbd "M-s") 'puni-splice)
    (define-key puni-mode-map (kbd "M-S") 'puni-split)
    (define-key puni-mode-map (kbd "M-J") 'puni-join)
    (define-key puni-mode-map (kbd "M-r") 'puni-raise)
    (define-key puni-mode-map (kbd "C-)") 'puni-slurp-forward)
    (define-key puni-mode-map (kbd "C-(") 'puni-slurp-backward)
    (define-key puni-mode-map (kbd "C-}") 'puni-barf-forward)
    (define-key puni-mode-map (kbd "C-{") 'puni-barf-backward))

  ;; Optionally, disable Puni in term-mode
  ;;(add-hook 'term-mode-hook #'puni-disable-puni-mode)
#+end_src

** completion
#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :custom
    (corfu-auto t)
    (corfu-auto-delay 0.0)
    (corfu-auto-prefix 2)
    (corfu-preview-current t)
    (corfu-preselect-first t)
    :init
    (global-corfu-mode))

  ;; Cape for better completion sources
  (use-package cape
    :ensure t
    :init
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev))


  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook ((csharp-mode . lsp-deferred)
           ;; (fsharp-mode . lsp-deferred)
           )
    :config
    (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols)
    (setq lsp-prefer-capf t)
    (transient-define-prefix my/lsp-transient ()
    "LSP commands"
        [["Actions"
          ("d" "Definition" lsp-find-definition)
          ("?" "References" lsp-find-references)
          ("i" "Implementation" lsp-find-implementation)
          ("t" "Type Definition" lsp-find-type-definition)
          ("s" "Symbol" consult-lsp-symbols)
          ("f" "Format Buffer" lsp-format-buffer)
          ("a" "Code Action" lsp-execute-code-action)]
         ["Diagnostics"
          ("n" "Next Diagnostic" flycheck-next-error)
          ("p" "Previous Diagnostic" flycheck-previous-error)
          ("l" "List Diagnostics" lsp-ui-flycheck-list)]
         ["Workspace"
          ("R" "Restart Workspace" lsp-restart-workspace)
          ("q" "Shutdown Workspace" lsp-shutdown-workspace)
          ("r" "Rename Symbol" lsp-rename)]
         ["Other"
          ("m" "Toggle LSP Mode" lsp-mode)]]))


  ;; Make sure orderless works well with LSP
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides
     '((eglot-capf (styles orderless basic))
       (lsp-capf (styles orderless basic))
       (file (styles . (partial-completion orderless)))))
    (orderless-component-separator #'orderless-escapable-split-on-space)
    (orderless-matching-styles 
     '(orderless-literal
       orderless-prefixes
       orderless-flex)))

  ;; Optional: Add company-mode as a fallback
  ;; SLIME configuration
  (use-package slime
    :ensure t
    :defer t
    :init
    (setq inferior-lisp-program "sbcl")
    (setq slime-lisp-implementations
          '((sbcl ("sbcl" "--dynamic-space-size" "4Gb"))))
    :config
    (slime-setup '(slime-fancy slime-repl slime-scratch slime-trace-dialog slime-cl-indent slime-cape)))
  (use-package slime-cape
    :ensure (slime-cape :type git :host github :repo "ccqpein/slime-cape")
    :after (slime cape)
    :hook (slime . slime-cape)
    (slime-repl . slime-cape))

  (use-package vertico
    :ensure t
    :init
    (vertico-mode)
    :custom
    (vertico-resize nil)
    (vertico-count 17)
    (vertico-cycle t)
    :bind (:map vertico-map
                ("M-RET" . vertico-exit-input)
                ("C-SPC" . +vertico/embark-preview)
                ("C-n" . vertico-next)
                ("C-M-j" . vertico-next-group)
                ("C-e" . vertico-previous)
                ("C-M-k" . vertico-previous-group)
                :map minibuffer-local-map
                ("DEL" . vertico-directory-delete-char))
    :hook (minibuffer-setup . vertico-repeat-save))

  ;; Ensure fsharp-mode is  installed and required
  (use-package sharper
    :bind (("C-c d" . #'sharper-main-transient)))

  (use-package fsharp-mode)
  (add-hook 'web-mode-hook 'my-web-mode-hook)
  (add-hook 'eglot-managed-mode-hook (lambda () (+lsp-optimization-mode t)))
  (use-package eglot-fsharp)
  ;; SLIME-Cape integration
  (use-package yasnippet-capf
    :ensure t
    :after (cape yasnippet)
    :config
    (add-to-list 'completion-at-point-functions #'yasnippet-capf))

  ;; Configure hippie-expand with YASnippet
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode 1)
    (add-to-list 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
    (setq hippie-expand-try-functions-list
          (cons 'yas-hippie-try-expand
                (delq 'yas-hippie-try-expand hippie-expand-try-functions-list))))

  ;; Dabbrev configuration
  (use-package dabbrev
    :ensure nil  ; built-in package
    :config
    (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
    (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
    :bind ([remap dabbrev-expand] . hippie-expand))
#+end_src

** flycheck
#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src

#+RESULTS:
: t

** Transient keybinds
keybinding maps like magit

#+begin_src emacs-lisp
  ;; (transient-define-prefix my-code-transient ()
  ;;   "Window Movement"
  ;;   [["Actions"
  ;;     ("a" "Code-actions" eglot-code-actions)
  ;;     ("r" "Rename" eglot-rename)
  ;;     ("s" "Eglot Symbols" consult-eglot-symbols)
  ;;     ("f" "Format buffer" eglot-format-buffer)]
  ;;    ["Navigation"
  ;;     ("i" "Find implementation" eglot-find-implementation)
  ;;     ("d" "Find declaration" eglot-find-declaration)
  ;;     ("x" "show errors in active buffers" consult-flymake)]])
#+end_src

** tabspaces
like perps-mode, perps.el and perspective.el but simpler and utilizing the built in tab-bar-mode
#+begin_src emacs-lisp
  (use-package tabspaces
    :config
    (setf tabspaces-use-filtered-buffers-as-default t
          tabspaces-default-tab "Default"
          tabspaces-remove-to-default t
          tabspaces-include-buffers '("*scratch*")
          tabspaces-initialize-project-with-todo t
          tabspaces-todo-file-name "project-todo.org"
          tabspaces-session t)
    (tabspaces-mode 1)
    ;; Filter Buffers for Consult-Buffer

    (with-eval-after-load 'consult
      ;; hide full buffer list (still available with "b" prefix)
      (consult-customize consult--source-buffer :hidden t :default nil)
      ;; set consult-workspace buffer list
      (defvar consult--source-workspace
        (list :name     "Workspace Buffers"
              :narrow   ?w
              :history  'buffer-name-history
              :category 'buffer
              :state    #'consult--buffer-state
              :default  t
              :items    (lambda () (consult--buffer-query
                                    :predicate #'tabspaces--local-buffer-p
                                    :sort 'visibility
                                    :as #'buffer-name)))

        "Set workspace buffer list for consult-buffer.")

      (add-to-list 'consult-buffer-sources 'consult--source-workspace)))

  (transient-define-prefix tabspaces-transient ()
    "TabSpaces: Manage workspaces and buffers"
    [["Buffer Management"
      ("k" "Kill buffers & close ws" tabspaces-kill-buffers-close-workspace)
      ("c" "Clear buffers" tabspaces-clear-buffers)
      ("d" "Remove ted buffer" tabspaces-remove-selected-buffer)]
     ["Workspace Management"
      ("w" "Close workspace" tabspaces-close-workspace)
      ("s" "Switch/Create workspace" tabspaces-switch-or-create-workspace)
      ("o" "Open/Create project/ws" tabspaces-open-or-create-project-and-workspace)]
     ["Buffer Navigation"
      ("b" "Switch buffer" tabspaces-switch-to-buffer)
      ("t" "Switch buffer & tab" tabspaces-switch-buffer-and-tab)]])
#+end_src

** org gtd
#+begin_src emacs-lisp
  (use-package org-gtd
    :config
    (setf org-gtd-update-ack "3.0.0")
    (setf org-gtd-directory "~/Dropbox/org/")
    (org-gtd-mode 1)
    (transient-define-prefix my/org-gtd-transient-menu ()
      "Org GTD"
      ["Org GTD Commands"
       ("c" "Capture Task" org-capture)
       ("p" "Process Inbox" org-gtd-process-inbox)
       ("e" "Engage" org-gtd-engage)
       ("r" "organize" org-gtd-organize)
       ])
    (setf org-capture-templates
          '(("i" "Inbox" entry (file "~/Dropbox/org/inbox.org")
             "* %?\n%U\n" :prepend t)
            ("t" "Task" entry (file "~/Dropbox/org/inbox.org")
             "* TODO %?\n%U\n" :prepend t)
            ;; Add other templates here
            ))
    :bind (("C-c n" . my/org-gtd-transient-menu)))
#+end_src

#+RESULTS:
: my/org-gtd-transient-menu

** Garbage Collector Magic Hack

#+begin_src emacs lisp
  (use-package gcmh)
#+end_src
** Embark

#+begin_src emacs-lisp
  (use-package embark
    :config
    (defun embark-which-key-indicator ()
      "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
      (lambda (&optional keymap targets prefix)
        (if (null keymap)
            (which-key--hide-popup-ignore-command)
          (which-key--show-keymap
           (if (eq (plist-get (car targets) :type) 'embark-become)
               "Become"
             (format "Act on %s '%s'%s"
                     (plist-get (car targets) :type)
                     (embark--truncate-target (plist-get (car targets) :target))
                     (if (cdr targets) "â€¦" "")))
           (if prefix
               (pcase (lookup-key keymap prefix 'accept-default)
                 ((and (pred keymapp) km) km)
                 (_ (key-binding prefix 'accept-default)))
             keymap)
           nil nil t (lambda (binding)
                       (not (string-suffix-p "-argument" (cdr binding))))))))

    (setf embark-indicators
          '(embark-which-key-indicator
            embark-highlight-indicator
            embark-isearch-highlight-indicator))

    (defun embark-hide-which-key-indicator (fn &rest args)
      "Hide the which-key indicator immediately when using the completing-read prompter."
      (which-key--hide-popup-ignore-command)
      (let ((embark-indicators
             (remq #'embark-which-key-indicator embark-indicators)))
        (apply fn args)))

    (advice-add #'embark-completing-read-prompter
                :around #'embark-hide-which-key-indicator)
    :bind (("C-," . #'embark-act)
           ("C-:" . #'embark-dwim)
           ("C-h B" . #'embark-bindings))) ;;shows mode + minor key in a
                                           ;;searchable manner very
                                           ;;useful
  (use-package embark-consult)
#+end_src

** wgrep
makes grep buffers writeable.
#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src
** dslides
#+begin_src emacs-lisp
  (use-package dslide
    :config
    (set-face-attribute 'dslide-highlight nil :foreground "white" :background "green")
    (set-face-attribute 'dslide-babel-success-highlight nil :foreground "white" :background "blue")
    (set-face-attribute 'dslide-babel-error-highlight nil :foreground "white" :background "red")
    )
  (use-package default-text-scale
    :ensure t
    :config
    (default-text-scale-mode))
  (use-package moc
    :ensure (moc
             :host github
             :repo "positron-solutions/moc"))
#+end_src
some configuration for debugging slides 
#+begin_src emacs-lisp

#+end_src

#+RESULTS:
** pdf-tools
#+begin_src emacs-lisp
  (use-package pdf-tools
    :hook ((pdf-view-mode . pdf-tools-enable-minor-modes)
           (pdf-view-mode . pdf-view-midnight-minor-mode)
           (pdf-view-mode . (lambda () 
                              (display-line-numbers-mode -1)
                              (set-fringe-mode 0))))
    :config
    (pdf-tools-install))
#+end_src
** Lisps
*** Emacs Lisp
#+begin_src  emacs-lisp
  ;; match da pairs
  (electric-pair-mode 1)
  (add-hook 'org-mode-hook (lambda ()
                             (setq-local electric-pair-inhibit-predicate
                                         `(lambda (c)
                                            (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))

  (use-package aggressive-indent)
  ;; Enable paredit for Common Lisp programming
  (add-hook 'lisp-mode-hook #'aggressive-indent-mode)

  ;; Enable paredit for Emacs Lisp programming


  ;; (use-package elsa)      
  (use-package eros
    :config
    (setf eros-mode 1))

  ;; (aggressive-indent-global-mode 1)
#+end_src
** Common Lisp
#+begin_src emacs-lisp
  (use-package paredit
        :hook ((lisp-mode . #'enable-paredit-mode)
               (emacs-lisp-mode . #'enable-paredit-mode)))    
  ;;paren files should also be lispy lisp mode (js but in lisp ma god)
    (add-to-list 'auto-mode-alist (cons "\\.paren\\'" 'lisp-mode))
          (add-hook 'lisp-mode-hook
                    #'(lambda ()
                        (when (and buffer-file-name
                                   (string-match-p "\\.paren\\>" buffer-file-name))
                          (unless (slime-connected-p)
                            (save-excursion (slime)))
                          (trident-mode +1))))

          (defun steal-slime-keys-for-trident! ()
          ;; Don't affect all SLIME buffers, just where invoked
          (make-local-variable 'slime-mode-map)
          (let ((map slime-mode-map))
            (define-key map (kbd "C-x C-e") nil)
            (define-key map (kbd "C-c C-r") nil)
            (define-key map (kbd "C-M-x")   nil)
            (define-key map (kbd "C-c C-k") nil)
            (define-key map (kbd "C-c C-m") nil))
          (let ((map trident-mode-map))
            (define-key map (kbd "C-x C-e") 'trident-eval-last-expression)
            (define-key map (kbd "C-c C-r") 'trident-eval-region)
            (define-key map (kbd "C-M-x")   'trident-eval-defun)
            (define-key map (kbd "C-c C-k") 'trident-eval-buffer)
            (define-key map (kbd "C-c C-m") 'trident-expand-sexp)))

        (add-hook 'trident-mode-hook 'steal-slime-keys-for-trident!)
#+end_src
 
** GIFS
#+begin_src emacs-lisp
  (use-package gif-screencast
    :ensure t
    :config
    (setq gif-screencast-program "flameshot_bash")
    (setq gif-screencast-args '()))
    (use-package keycast)
#+end_src

#+RESULTS:
*** Flameshot Bash Script
#+PROPERTY: header-args:bash :tangle ~/bin/flameshot_bash
#+PROPERTY: header-args:bash :shebang 
#+begin_src bash :tangle ~/bin/flameshot_bash :shebang "#!/bin/bash"
  flameshot full -r>"$1"
#+end_src
#+RESULTS:

** web
#+begin_src emacs-lisp
  (use-package impatient-mode
    :ensure t
    :hook ((clog-mode . impatient-mode)
           (html-mode . impatient-mode)
           (css-mode . impatient-mode)
           (mhtml-mode . impatient-mode)))

  ;; Configure mhtml-mode for .clog files
  (use-package mhtml-mode
    :ensure nil
    :mode ("\\.clog\\'" . mhtml-mode))
#+end_src
#+RESULTS:
: ps-sly-eval-defun

** regex
#+begin_src emacs-lisp
  (use-package ample-regexps
        :ensure t
        :config
        (define-arx guid-rx
      '((hex-char (regexp "[0-9a-fA-F]"))
        (guid-group4 (seq (= 4 hex-char)))
        (guid-group8 (seq (= 8 hex-char)))
        (guid-group12 (seq (= 12 hex-char)))
        (guid-sep (or "-" ""))  ; Handles both with and without hyphens
        (guid (seq 
               (or "{" "" "<")  ; Optional opening bracket
               guid-group8 guid-sep
               guid-group4 guid-sep
               guid-group4 guid-sep
               guid-group4 guid-sep
               guid-group12
               (or "}" "" ">"))))))

    ; Optional closing bracket

    ;; Examples of how to use it:
    ;; (guid-rx guid)  ; This will create the regexp
#+end_src

** bicep-ts-mode
#+begin_src emacs-lisp
  (use-package bicep-ts-mode
    :config
    (with-eval-after-load 'lsp-mode
      (add-to-list 'lsp-language-id-configuration '(bicep-ts-mode . "bicep"))
      (lsp-register-client
       (make-lsp-client :new-connection (lsp-stdio-connection '("dotnet" "/usr/local/bin/bicep-langserver/Bicep.LangServer.dll"))
                        :activation-fn (lsp-activate-on "bicep")
                        :server-id 'bicep))))
#+end_src
* Finans
#+begin_src emacs-lisp
  (use-package ledger-mode
    :mode ("\\.dat\\'"
           "\\.ledger\\'")
    :custom (ledger-clear-whole-transactions t)
    :config
    (defvar ledger-file "/home/karim/Dropbox/ledger/ledger.dat"
    "Path to your main Ledger file.")

  (defun ledger-custom-report (name command)
    "Run a custom Ledger report with NAME and COMMAND."
    (let ((report-name (format "Custom: %s" name)))
      (add-to-list 'ledger-reports `(,report-name ,command) t)
      (ledger-report report-name nil)
      (delete-other-windows)))

  (transient-define-prefix ledger-reports-transient ()
    "Transient for running Ledger reports."
    :transient-suffix 'transient--do-stay
    ["Ledger Reports"
     ("n" "Net Worth" (lambda () (interactive) 
                        (ledger-custom-report "Net Worth" "%(binary) -f %(ledger-file) balance ^Assets ^Liabilities ^Equity and not %Equity:Budget -R")))
     ("i" "Income Statement" (lambda () (interactive) 
                               (ledger-custom-report "Income Statement" "%(binary) -f %(ledger-file) balance ^Income ^Expenses -R")))
     ("r" "Retained Earnings" (lambda () (interactive) 
                                (ledger-custom-report "Retained Earnings" "%(binary) -f %(ledger-file) balance ^Income ^Expenses -R --sum")))
     ("b" "Budget Status" (lambda () (interactive) 
                            (ledger-custom-report "Budget Status" "%(binary) -f %(ledger-file) balance ^Budget")))
     ("a" "All Accounts" (lambda () (interactive) 
                           (ledger-custom-report "All Accounts" "%(binary) -f %(ledger-file) balance ^Assets")))
     ("e" "Expenses" (lambda () (interactive) 
                       (ledger-custom-report "Expenses" "%(binary) -f %(ledger-file) balance ^Expenses -R")))
     ("m" "Monthly Expenses" (lambda () (interactive) 
                               (ledger-custom-report "Monthly Expenses" "%(binary) -f %(ledger-file) --monthly balance ^Expenses -R")))])

  (global-set-key (kbd "C-c l") #'ledger-reports-transient)

  (ledger-reports-add "Cash Flow" "ledger -f %(ledger-file) -p %(month) register ^Assets:Checking")
  (ledger-reports-add "Budget vs. Actual" "ledger -f %(ledger-file) -p %(month) --budget --depth 2 balance ^Expenses"))

  (use-package flycheck-ledger :after ledger-mode)
#+end_src

#+RESULTS:
: ledger-reports-transient


* Wrap Up
** Guix Emacs Profile
 
*.config/guix/manifests/emacs.scm:*
 
#+begin_src scheme :mkdirp yes :tangle ~/.config/guix/manifests/emacs.scm :noweb yes
  (specifications->manifest
   '("emacs"
     <<packages>>
  ))
#+end_src

 
